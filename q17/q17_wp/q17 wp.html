<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.0.4 (457911)"/><meta name="altitude" content="62.18050003051758"/><meta name="author" content="315793290@qq.com"/><meta name="created" content="2019-05-10 13:20:38 +0000"/><meta name="latitude" content="39.95007556026686"/><meta name="longitude" content="116.2305121657063"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2019-05-10 13:54:36 +0000"/><title>q17 wp</title></head><body><div>q17的反调试技术：</div><ol><li><div><span>rdtsc 相减 / 10**9 ，导致所有的调试，包括硬件断点都失败。</span></div></li><li><div>不断地取代码段的内容作为运算的参数，这样保证了程序的不可修改性，一旦修改程序，就会导致结果计算错误，也就是说不能使用软件断点的调试方法。相应的，gdb里的b,ni , finish等有可能会对程序做修改的操作都是禁止了。但是si操作是允许的，根据大佬巨神的说话，单步调试并不改变代码段的内容，而是在eflags寄存器上置上一个标记位，以使其被对应的ptrace函数捕获。</div></li></ol><div><br/></div><div><br/></div><div>q17的调试方法：</div><ol><li><div>patch掉rdtsc相减那部分，拿patch结束后的程序去做验证。</div></li><li><div>patch后只使用hb硬件中断和单步调试的方法。</div></li><li><div>最关键的是要将q17抄写为python，理清内部逻辑（踩坑点）</div></li></ol><div><br/></div><div>q17抄写巨坑：</div><ol><li><div>首先就是有符号乘的问题，imul指令是需要特别注意的地方。有符号乘和无符号乘的操作是存在差异的，以32位的操作数为例：对于无符号乘 a*b = a*b , 对于有符号乘，采用的就是补码乘法，a*b=(a-2**32)*(b-2**32) = a*b - (a+b)*(2**32)</div></li><li><div>其次就是ida反汇编的问题，抄写的时候注意符号拓展问题。对于cdqe和movsxd等汇编指令要特别注意，也就是当抄写结果出错时，要注意这种符号拓展在反汇编的伪c代码中可能没有表现的问题。</div></li><li><div>还有就是对于常见的静态编译的库函数（有可能不是标准的libc），要有足够的经验去猜测其函数名。比如q17中使用的fgtec(buf,n,stdin)函数，需要能够第一时间反应，注意到将最后一个字节置为\0的问题。</div></li><li><div>对于随机数的获取的一种比较装逼的写法：</div></li></ol><div>           <br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>#from hashlib import sha512</div><div>#inp=''.join(sha512(seed).digest().encode('base64').split())[:64]</div></div><div><br/></div><div><br/></div><div>q17求逆的坑点：</div><ol><li><div>常见的整数溢出的问题需要注意，不要遗漏，需要足够细心</div></li><li><div>其次就是求模运算的问题。</div></li></ol><div>           假设 ax+by +c= d mod (m),在正向求解d的过程中，如果x,y 和m的长度不一样，更确切的说当x,y比m的字节数要长，或者说x,y比m更高阶的情况下，是会存在信息丢失的。</div><div>           这个信息丢失就在于当我们求逆解x或者y的时候，是无法恢复x的高位部分，假设求x，那么x = (d+c - by )* (a** -1)  mod m。  因为是带模运算，x的高位信息是丢失的。这里的x值只是其中的一个通解（一般是最小）。</div><div>     </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>